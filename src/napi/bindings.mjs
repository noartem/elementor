import bindings from "./bindings-data.mjs";

const classes = {};

for (const name in bindings) {
    const {constructor, methods} = bindings[name];

    const methodsHeader = Object.keys(methods).map(
        (method) => `Napi::Value ${method}(const Napi::CallbackInfo &info);`,
    ).join(`

    `);

    const header = `class N${name} : public Napi::ObjectWrap<N${name}> {
public:
    N${name}(const Napi::CallbackInfo &info);

    static Napi::Function GetClass(Napi::Env);

    Napi::Value getInstance(const Napi::CallbackInfo &info);
    
    ${methodsHeader}

private:
    std::shared_ptr <${name}> instance;
};`;

    const constructorDefaultBody = `    if (info.Length() == 1 && info[0].IsExternal()) {
        this->instance = *info[0].As < Napi::External < std::shared_ptr < ${name}>>>().Data();
        return;
    }

    this->instance = std::make_shared<${name}>();`;

    const constructorArgsCheck = constructor?.args?.length
        ? `    if (info.Length() < ${constructor.args.length}) {
        Napi::TypeError::New(env, "${name}: Excepted >=${
            constructor.args.length
        } arguments").ThrowAsJavaScriptException();
        return;
    }

    ${constructor.args.map(
            (arg, i) => `auto _${arg.name} = parse_napi_${arg.type}(env, info[${i}]);
    if (!_${arg.name}.has_value()) {
        Napi::TypeError::New(env, "${name}: " + parse_error_to_string(_${arg.name}.error())).ThrowAsJavaScriptException();
        return;
    }
    auto ${arg.name} = _${arg.name}.value();`,
        ).join(`

\t  `)}

`
        : "";

    const constructorSource = `N${name}::N${name}(const Napi::CallbackInfo &info) : ObjectWrap(info) {
    Napi::Env env = info.Env();
${constructorArgsCheck}${(constructor?.body ?? constructorDefaultBody)
        .split("\n")
        .map((e) => e.trim())
        .map((e) => (e ? `    ${e}` : ""))
        .join("\n")}
}`;

    const getClass = `Napi::Function N${name}::GetClass(Napi::Env env) {
    return DefineClass(env, "N${name}", {
            ${Object.keys(methods).concat("getInstance").map(
        (method) =>
            `N${name}::InstanceMethod("${method}", &N${name}::${method})`,
    ).join(`,
            `)}
    });
}`;

    const getInstanceMethod = `Napi::Value N${name}::getInstance(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    return Napi::External < std::shared_ptr < ${name} >> ::New(env, &this->instance).As<Napi::Value>();
}`;

    const methodsSource = Object.keys(methods).map((method) => {
        const {args = [], body} = methods[method];

        const argsCheck =
            args.length > 0
                ? `if (info.Length() < ${args.length}) {
        Napi::TypeError::New(env, "${name} ${method}: Excepted >=${
                    args.length
                } arguments").ThrowAsJavaScriptException();
        return env.Undefined();
    }

    ${args.map(
                    (arg, i) => `auto _${arg.name} = parse_napi_${arg.type}(env, info[${i}]);
    if (!_${arg.name}.has_value()) {
        Napi::TypeError::New(env, "${name} ${method}: " + parse_error_to_string(_${arg.name}.error())).ThrowAsJavaScriptException();
        return env.Undefined();
    }
    auto ${arg.name} = _${arg.name}.value();`,
                ).join(`

\t  `)}
`
                : "";

        return `Napi::Value N${name}::${method}(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    ${argsCheck}
${body
            .split("\n")
            .map((e) => e.trim())
            .map((e) => (e ? `    ${e}` : ""))
            .join("\n")}
    return env.Undefined();
}`;
    });

    const source = [
        constructorSource,
        getClass,
        getInstanceMethod,
        ...methodsSource,
    ].join("\n\n");

    classes[name] = {header, source};
}

const header = `// generated by src/napi/bindings.mjs
#pragma once

#include "library.h"

#include <napi.h>

${Object.values(classes)
    .map((e) => e.header)
    .join("\n\n\n")}
`;

const source = `// generated by src/napi/bindings.mjs
#include "elementor.h"
#include "parse.h"

#include <napi.h>
#include <tl/expected.hpp>

${Object.values(classes)
    .map((e) => e.source)
    .join("\n\n")}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
    ${Object.keys(classes).map(
    (name) =>
        `exports.Set(Napi::String::New(env, "N${name}"), N${name}::GetClass(env));`,
).join(`
    `)}
    return exports;
}

NODE_API_MODULE(addon, Init)
`;

export default {header, source};
